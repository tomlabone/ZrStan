
// Code generated by stanc v2.27.0
#include <stan/model/model_header.hpp>
namespace zircon_all_model_namespace {

using stan::io::dump;
using stan::model::assign;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 192> locations_array__ = 
{" (found before start of program)",
 " (in 'Zr/zircon-all.stan', line 160, column 2 to column 14)",
 " (in 'Zr/zircon-all.stan', line 161, column 2 to column 18)",
 " (in 'Zr/zircon-all.stan', line 162, column 2 to column 24)",
 " (in 'Zr/zircon-all.stan', line 163, column 2 to column 20)",
 " (in 'Zr/zircon-all.stan', line 164, column 2 to column 19)",
 " (in 'Zr/zircon-all.stan', line 169, column 2 to column 20)",
 " (in 'Zr/zircon-all.stan', line 170, column 2 to column 17)",
 " (in 'Zr/zircon-all.stan', line 171, column 2 to column 16)",
 " (in 'Zr/zircon-all.stan', line 172, column 2 to column 9)",
 " (in 'Zr/zircon-all.stan', line 173, column 2 to column 17)",
 " (in 'Zr/zircon-all.stan', line 175, column 2 to column 27)",
 " (in 'Zr/zircon-all.stan', line 176, column 2 to column 33)",
 " (in 'Zr/zircon-all.stan', line 179, column 4 to column 25)",
 " (in 'Zr/zircon-all.stan', line 180, column 4 to column 18)",
 " (in 'Zr/zircon-all.stan', line 182, column 4 to line 184, column 52)",
 " (in 'Zr/zircon-all.stan', line 186, column 4 to line 187, column 71)",
 " (in 'Zr/zircon-all.stan', line 178, column 16 to line 189, column 5)",
 " (in 'Zr/zircon-all.stan', line 178, column 2 to line 189, column 5)",
 " (in 'Zr/zircon-all.stan', line 208, column 2 to column 19)",
 " (in 'Zr/zircon-all.stan', line 209, column 2 to column 21)",
 " (in 'Zr/zircon-all.stan', line 211, column 4 to column 74)",
 " (in 'Zr/zircon-all.stan', line 212, column 4 to line 214, column 5)",
 " (in 'Zr/zircon-all.stan', line 213, column 6 to column 55)",
 " (in 'Zr/zircon-all.stan', line 210, column 16 to line 215, column 3)",
 " (in 'Zr/zircon-all.stan', line 210, column 2 to line 215, column 3)",
 " (in 'Zr/zircon-all.stan', line 194, column 2 to column 24)",
 " (in 'Zr/zircon-all.stan', line 195, column 2 to column 45)",
 " (in 'Zr/zircon-all.stan', line 196, column 2 to column 33)",
 " (in 'Zr/zircon-all.stan', line 199, column 4 to column 40)",
 " (in 'Zr/zircon-all.stan', line 200, column 4 to column 39)",
 " (in 'Zr/zircon-all.stan', line 201, column 4 to column 65)",
 " (in 'Zr/zircon-all.stan', line 198, column 16 to line 202, column 3)",
 " (in 'Zr/zircon-all.stan', line 198, column 2 to line 202, column 3)",
 " (in 'Zr/zircon-all.stan', line 137, column 2 to column 11)",
 " (in 'Zr/zircon-all.stan', line 138, column 2 to column 8)",
 " (in 'Zr/zircon-all.stan', line 139, column 8 to column 9)",
 " (in 'Zr/zircon-all.stan', line 139, column 2 to column 11)",
 " (in 'Zr/zircon-all.stan', line 140, column 10 to column 14)",
 " (in 'Zr/zircon-all.stan', line 140, column 2 to column 16)",
 " (in 'Zr/zircon-all.stan', line 141, column 9 to column 13)",
 " (in 'Zr/zircon-all.stan', line 141, column 2 to column 17)",
 " (in 'Zr/zircon-all.stan', line 142, column 9 to column 13)",
 " (in 'Zr/zircon-all.stan', line 142, column 2 to column 18)",
 " (in 'Zr/zircon-all.stan', line 143, column 9 to column 13)",
 " (in 'Zr/zircon-all.stan', line 143, column 2 to column 17)",
 " (in 'Zr/zircon-all.stan', line 144, column 9 to column 13)",
 " (in 'Zr/zircon-all.stan', line 144, column 2 to column 17)",
 " (in 'Zr/zircon-all.stan', line 145, column 2 to column 9)",
 " (in 'Zr/zircon-all.stan', line 146, column 2 to column 9)",
 " (in 'Zr/zircon-all.stan', line 147, column 8 to column 10)",
 " (in 'Zr/zircon-all.stan', line 147, column 2 to column 14)",
 " (in 'Zr/zircon-all.stan', line 148, column 9 to column 10)",
 " (in 'Zr/zircon-all.stan', line 148, column 2 to column 17)",
 " (in 'Zr/zircon-all.stan', line 149, column 9 to column 10)",
 " (in 'Zr/zircon-all.stan', line 149, column 2 to column 20)",
 " (in 'Zr/zircon-all.stan', line 150, column 9 to column 11)",
 " (in 'Zr/zircon-all.stan', line 150, column 2 to column 22)",
 " (in 'Zr/zircon-all.stan', line 151, column 9 to column 11)",
 " (in 'Zr/zircon-all.stan', line 151, column 12 to column 14)",
 " (in 'Zr/zircon-all.stan', line 151, column 2 to column 28)",
 " (in 'Zr/zircon-all.stan', line 152, column 2 to column 14)",
 " (in 'Zr/zircon-all.stan', line 153, column 2 to column 17)",
 " (in 'Zr/zircon-all.stan', line 154, column 2 to column 11)",
 " (in 'Zr/zircon-all.stan', line 155, column 2 to column 10)",
 " (in 'Zr/zircon-all.stan', line 160, column 9 to column 10)",
 " (in 'Zr/zircon-all.stan', line 161, column 9 to column 11)",
 " (in 'Zr/zircon-all.stan', line 161, column 12 to column 13)",
 " (in 'Zr/zircon-all.stan', line 162, column 14 to column 16)",
 " (in 'Zr/zircon-all.stan', line 164, column 9 to column 11)",
 " (in 'Zr/zircon-all.stan', line 169, column 13 to column 15)",
 " (in 'Zr/zircon-all.stan', line 170, column 9 to column 11)",
 " (in 'Zr/zircon-all.stan', line 171, column 9 to column 11)",
 " (in 'Zr/zircon-all.stan', line 173, column 9 to column 13)",
 " (in 'Zr/zircon-all.stan', line 208, column 13 to column 17)",
 " (in 'Zr/zircon-all.stan', line 209, column 15 to column 19)",
 " (in 'Zr/zircon-all.stan', line 10, column 2 to column 12)",
 " (in 'Zr/zircon-all.stan', line 11, column 9 to column 16)",
 " (in 'Zr/zircon-all.stan', line 11, column 17 to column 24)",
 " (in 'Zr/zircon-all.stan', line 11, column 2 to column 28)",
 " (in 'Zr/zircon-all.stan', line 12, column 2 to column 8)",
 " (in 'Zr/zircon-all.stan', line 14, column 4 to column 13)",
 " (in 'Zr/zircon-all.stan', line 16, column 6 to column 27)",
 " (in 'Zr/zircon-all.stan', line 15, column 23 to line 17, column 5)",
 " (in 'Zr/zircon-all.stan', line 15, column 4 to line 17, column 5)",
 " (in 'Zr/zircon-all.stan', line 18, column 4 to column 28)",
 " (in 'Zr/zircon-all.stan', line 13, column 22 to line 19, column 3)",
 " (in 'Zr/zircon-all.stan', line 13, column 2 to line 19, column 3)",
 " (in 'Zr/zircon-all.stan', line 20, column 2 to column 11)",
 " (in 'Zr/zircon-all.stan', line 9, column 36 to line 21, column 1)",
 " (in 'Zr/zircon-all.stan', line 25, column 9 to column 16)",
 " (in 'Zr/zircon-all.stan', line 25, column 17 to column 24)",
 " (in 'Zr/zircon-all.stan', line 25, column 2 to column 28)",
 " (in 'Zr/zircon-all.stan', line 26, column 9 to column 16)",
 " (in 'Zr/zircon-all.stan', line 26, column 2 to column 20)",
 " (in 'Zr/zircon-all.stan', line 27, column 2 to column 28)",
 " (in 'Zr/zircon-all.stan', line 29, column 4 to column 27)",
 " (in 'Zr/zircon-all.stan', line 31, column 6 to column 33)",
 " (in 'Zr/zircon-all.stan', line 30, column 25 to line 32, column 5)",
 " (in 'Zr/zircon-all.stan', line 30, column 4 to line 32, column 5)",
 " (in 'Zr/zircon-all.stan', line 28, column 23 to line 33, column 3)",
 " (in 'Zr/zircon-all.stan', line 28, column 2 to line 33, column 3)",
 " (in 'Zr/zircon-all.stan', line 34, column 2 to column 11)",
 " (in 'Zr/zircon-all.stan', line 24, column 49 to line 35, column 1)",
 " (in 'Zr/zircon-all.stan', line 39, column 9 to column 11)",
 " (in 'Zr/zircon-all.stan', line 39, column 2 to column 16)",
 " (in 'Zr/zircon-all.stan', line 40, column 9 to column 11)",
 " (in 'Zr/zircon-all.stan', line 40, column 12 to column 14)",
 " (in 'Zr/zircon-all.stan', line 40, column 2 to column 18)",
 " (in 'Zr/zircon-all.stan', line 41, column 9 to column 16)",
 " (in 'Zr/zircon-all.stan', line 41, column 2 to column 26)",
 " (in 'Zr/zircon-all.stan', line 42, column 2 to column 24)",
 " (in 'Zr/zircon-all.stan', line 43, column 2 to column 14)",
 " (in 'Zr/zircon-all.stan', line 44, column 2 to column 26)",
 " (in 'Zr/zircon-all.stan', line 46, column 4 to column 29)",
 " (in 'Zr/zircon-all.stan', line 45, column 17 to line 47, column 3)",
 " (in 'Zr/zircon-all.stan', line 45, column 2 to line 47, column 3)",
 " (in 'Zr/zircon-all.stan', line 48, column 2 to column 16)",
 " (in 'Zr/zircon-all.stan', line 49, column 2 to column 30)",
 " (in 'Zr/zircon-all.stan', line 50, column 2 to column 18)",
 " (in 'Zr/zircon-all.stan', line 38, column 70 to line 51, column 1)",
 " (in 'Zr/zircon-all.stan', line 54, column 2 to column 12)",
 " (in 'Zr/zircon-all.stan', line 55, column 2 to column 12)",
 " (in 'Zr/zircon-all.stan', line 58, column 8 to column 26)",
 " (in 'Zr/zircon-all.stan', line 57, column 24 to line 59, column 5)",
 " (in 'Zr/zircon-all.stan', line 57, column 4 to line 59, column 5)",
 " (in 'Zr/zircon-all.stan', line 56, column 32 to line 60, column 3)",
 " (in 'Zr/zircon-all.stan', line 56, column 2 to line 60, column 3)",
 " (in 'Zr/zircon-all.stan', line 61, column 2 to column 16)",
 " (in 'Zr/zircon-all.stan', line 53, column 35 to line 62, column 1)",
 " (in 'Zr/zircon-all.stan', line 65, column 2 to column 12)",
 " (in 'Zr/zircon-all.stan', line 66, column 2 to column 12)",
 " (in 'Zr/zircon-all.stan', line 70, column 8 to column 26)",
 " (in 'Zr/zircon-all.stan', line 69, column 23 to line 71, column 7)",
 " (in 'Zr/zircon-all.stan', line 69, column 6 to line 71, column 7)",
 " (in 'Zr/zircon-all.stan', line 68, column 24 to line 72, column 5)",
 " (in 'Zr/zircon-all.stan', line 68, column 4 to line 72, column 5)",
 " (in 'Zr/zircon-all.stan', line 67, column 32 to line 73, column 3)",
 " (in 'Zr/zircon-all.stan', line 67, column 2 to line 73, column 3)",
 " (in 'Zr/zircon-all.stan', line 74, column 2 to column 16)",
 " (in 'Zr/zircon-all.stan', line 64, column 45 to line 75, column 1)",
 " (in 'Zr/zircon-all.stan', line 78, column 2 to column 12)",
 " (in 'Zr/zircon-all.stan', line 79, column 2 to column 12)",
 " (in 'Zr/zircon-all.stan', line 83, column 8 to column 26)",
 " (in 'Zr/zircon-all.stan', line 82, column 22 to line 84, column 7)",
 " (in 'Zr/zircon-all.stan', line 82, column 6 to line 84, column 7)",
 " (in 'Zr/zircon-all.stan', line 81, column 24 to line 85, column 5)",
 " (in 'Zr/zircon-all.stan', line 81, column 4 to line 85, column 5)",
 " (in 'Zr/zircon-all.stan', line 80, column 32 to line 86, column 3)",
 " (in 'Zr/zircon-all.stan', line 80, column 2 to line 86, column 3)",
 " (in 'Zr/zircon-all.stan', line 87, column 2 to column 16)",
 " (in 'Zr/zircon-all.stan', line 77, column 45 to line 88, column 1)",
 " (in 'Zr/zircon-all.stan', line 91, column 10 to column 30)",
 " (in 'Zr/zircon-all.stan', line 91, column 2 to column 32)",
 " (in 'Zr/zircon-all.stan', line 92, column 2 to column 9)",
 " (in 'Zr/zircon-all.stan', line 93, column 2 to column 9)",
 " (in 'Zr/zircon-all.stan', line 96, column 6 to column 18)",
 " (in 'Zr/zircon-all.stan', line 97, column 6 to column 18)",
 " (in 'Zr/zircon-all.stan', line 95, column 24 to line 98, column 5)",
 " (in 'Zr/zircon-all.stan', line 95, column 4 to line 98, column 5)",
 " (in 'Zr/zircon-all.stan', line 94, column 32 to line 99, column 3)",
 " (in 'Zr/zircon-all.stan', line 94, column 2 to line 99, column 3)",
 " (in 'Zr/zircon-all.stan', line 100, column 2 to column 14)",
 " (in 'Zr/zircon-all.stan', line 90, column 32 to line 101, column 1)",
 " (in 'Zr/zircon-all.stan', line 104, column 10 to column 33)",
 " (in 'Zr/zircon-all.stan', line 104, column 2 to column 35)",
 " (in 'Zr/zircon-all.stan', line 105, column 2 to column 9)",
 " (in 'Zr/zircon-all.stan', line 106, column 2 to column 9)",
 " (in 'Zr/zircon-all.stan', line 110, column 8 to column 20)",
 " (in 'Zr/zircon-all.stan', line 111, column 8 to column 20)",
 " (in 'Zr/zircon-all.stan', line 109, column 22 to line 112, column 7)",
 " (in 'Zr/zircon-all.stan', line 109, column 6 to line 112, column 7)",
 " (in 'Zr/zircon-all.stan', line 108, column 22 to line 113, column 5)",
 " (in 'Zr/zircon-all.stan', line 108, column 4 to line 113, column 5)",
 " (in 'Zr/zircon-all.stan', line 107, column 32 to line 114, column 3)",
 " (in 'Zr/zircon-all.stan', line 107, column 2 to line 114, column 3)",
 " (in 'Zr/zircon-all.stan', line 115, column 2 to column 14)",
 " (in 'Zr/zircon-all.stan', line 103, column 42 to line 116, column 1)",
 " (in 'Zr/zircon-all.stan', line 119, column 10 to column 33)",
 " (in 'Zr/zircon-all.stan', line 119, column 2 to column 35)",
 " (in 'Zr/zircon-all.stan', line 120, column 2 to column 9)",
 " (in 'Zr/zircon-all.stan', line 121, column 2 to column 9)",
 " (in 'Zr/zircon-all.stan', line 125, column 8 to column 20)",
 " (in 'Zr/zircon-all.stan', line 126, column 8 to column 20)",
 " (in 'Zr/zircon-all.stan', line 124, column 23 to line 127, column 7)",
 " (in 'Zr/zircon-all.stan', line 124, column 6 to line 127, column 7)",
 " (in 'Zr/zircon-all.stan', line 123, column 22 to line 128, column 5)",
 " (in 'Zr/zircon-all.stan', line 123, column 4 to line 128, column 5)",
 " (in 'Zr/zircon-all.stan', line 122, column 32 to line 129, column 3)",
 " (in 'Zr/zircon-all.stan', line 122, column 2 to line 129, column 3)",
 " (in 'Zr/zircon-all.stan', line 130, column 2 to column 14)",
 " (in 'Zr/zircon-all.stan', line 118, column 42 to line 131, column 1)"};


template <typename T0__, typename T1__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>,
T1__>, -1, -1>
trrc(const T0__& k_arg__, const T1__& lambda, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>,
          T1__>;
  int current_statement__ = 0; 
  const auto& k = to_ref(k_arg__);
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    local_scalar_t__ Ksum;
    Ksum = DUMMY_VAR__;
    
    current_statement__ = 77;
    validate_non_negative_index("K", "rows(k)", rows(k));
    current_statement__ = 78;
    validate_non_negative_index("K", "rows(k)", rows(k));
    Eigen::Matrix<local_scalar_t__, -1, -1> K;
    K = Eigen::Matrix<local_scalar_t__, -1, -1>(rows(k), rows(k));
    stan::math::fill(K, DUMMY_VAR__);
    
    current_statement__ = 80;
    assign(K, k, "assigning variable K");
    current_statement__ = 87;
    for (int i = 1; i <= rows(K); ++i) {
      current_statement__ = 81;
      Ksum = 0;
      current_statement__ = 84;
      for (int j = 1; j <= rows(K); ++j) {
        current_statement__ = 82;
        Ksum = (Ksum + rvalue(k, "k", index_uni(i), index_uni(j)));
      }
      current_statement__ = 85;
      assign(K, (-Ksum - lambda),
        "assigning variable K", index_uni(i), index_uni(i));
    }
    current_statement__ = 88;
    return K;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct trrc_functor__ {
template <typename T0__, typename T1__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>,
T1__>, -1, -1>
operator()(const T0__& k, const T1__& lambda, std::ostream* pstream__)  const 
{
return trrc(k, lambda, pstream__);
}
};

template <typename T1__, typename T2__, typename T3__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T1__>, stan::value_type_t<T2__>,
stan::value_type_t<T3__>>, -1, 1>
q_me(const int& c, const T1__& x_arg__, const T2__& q0_arg__,
     const T3__& k_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T1__>,
          stan::value_type_t<T2__>,
          stan::value_type_t<T3__>>;
  int current_statement__ = 0; 
  const auto& x = to_ref(x_arg__);
  const auto& q0 = to_ref(q0_arg__);
  const auto& k = to_ref(k_arg__);
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 90;
    validate_non_negative_index("a", "rows(k)", rows(k));
    current_statement__ = 91;
    validate_non_negative_index("a", "rows(k)", rows(k));
    Eigen::Matrix<local_scalar_t__, -1, -1> a;
    a = Eigen::Matrix<local_scalar_t__, -1, -1>(rows(k), rows(k));
    stan::math::fill(a, DUMMY_VAR__);
    
    current_statement__ = 93;
    validate_non_negative_index("q", "rows(x)", rows(x));
    Eigen::Matrix<local_scalar_t__, -1, 1> q;
    q = Eigen::Matrix<local_scalar_t__, -1, 1>(rows(x));
    stan::math::fill(q, DUMMY_VAR__);
    
    current_statement__ = 95;
    assign(q, rep_vector(0, rows(x)), "assigning variable q");
    current_statement__ = 101;
    for (int i = 1; i <= rows(x); ++i) {
      current_statement__ = 96;
      assign(a, matrix_exp(multiply(k, rvalue(x, "x", index_uni(i)))),
        "assigning variable a");
      current_statement__ = 99;
      for (int j = 1; j <= rows(k); ++j) {
        current_statement__ = 97;
        assign(q,
          (rvalue(q, "q", index_uni(i)) +
            (rvalue(a, "a", index_uni(j), index_uni(c)) *
              rvalue(q0, "q0", index_uni(j)))),
          "assigning variable q", index_uni(i));
      }
    }
    current_statement__ = 102;
    return q;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct q_me_functor__ {
template <typename T1__, typename T2__, typename T3__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T1__>, stan::value_type_t<T2__>,
stan::value_type_t<T3__>>, -1, 1>
operator()(const int& c, const T1__& x, const T2__& q0, const T3__& k,
           std::ostream* pstream__)  const 
{
return q_me(c, x, q0, k, pstream__);
}
};

template <typename T1__, typename T2__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T1__>,
stan::value_type_t<T2__>>, -1, 1>
q_c(const int& comp, const T1__& x_arg__, const T2__& kt_arg__,
    const std::vector<std::vector<int>>& H, const int& nc, const int& nt,
    std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T1__>,
          stan::value_type_t<T2__>>;
  int current_statement__ = 0; 
  const auto& x = to_ref(x_arg__);
  const auto& kt = to_ref(kt_arg__);
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 104;
    validate_non_negative_index("q0", "nc", nc);
    Eigen::Matrix<local_scalar_t__, -1, 1> q0;
    q0 = Eigen::Matrix<local_scalar_t__, -1, 1>(nc);
    stan::math::fill(q0, DUMMY_VAR__);
    
    current_statement__ = 106;
    validate_non_negative_index("k", "nc", nc);
    current_statement__ = 107;
    validate_non_negative_index("k", "nc", nc);
    Eigen::Matrix<local_scalar_t__, -1, -1> k;
    k = Eigen::Matrix<local_scalar_t__, -1, -1>(nc, nc);
    stan::math::fill(k, DUMMY_VAR__);
    
    current_statement__ = 109;
    validate_non_negative_index("content", "rows(x)", rows(x));
    Eigen::Matrix<local_scalar_t__, -1, 1> content;
    content = Eigen::Matrix<local_scalar_t__, -1, 1>(rows(x));
    stan::math::fill(content, DUMMY_VAR__);
    
    current_statement__ = 111;
    assign(q0, rep_vector(0, nc), "assigning variable q0");
    current_statement__ = 112;
    assign(q0, 1.0, "assigning variable q0", index_uni(1));
    current_statement__ = 113;
    assign(k, rep_matrix(0, nc, nc), "assigning variable k");
    current_statement__ = 116;
    for (int i = 1; i <= nt; ++i) {
      current_statement__ = 114;
      assign(k, rvalue(kt, "kt", index_uni(i)),
        "assigning variable k", index_uni(rvalue(H, "H",
                                            index_uni(i), index_uni(1))),
                                  index_uni(rvalue(H, "H",
                                              index_uni(i), index_uni(2))));
    }
    current_statement__ = 117;
    assign(k, trrc(stan::model::deep_copy(k), 0, pstream__),
      "assigning variable k");
    current_statement__ = 118;
    assign(content, q_me(comp, x, q0, k, pstream__),
      "assigning variable content");
    current_statement__ = 119;
    return content;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct q_c_functor__ {
template <typename T1__, typename T2__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T1__>,
stan::value_type_t<T2__>>, -1, 1>
operator()(const int& comp, const T1__& x, const T2__& kt,
           const std::vector<std::vector<int>>& H, const int& nc,
           const int& nt, std::ostream* pstream__)  const 
{
return q_c(comp, x, kt, H, nc, nt, pstream__);
}
};

int
count_sub(const std::vector<int>& sub, const int& index,
          std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0; 
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    int count;
    count = std::numeric_limits<int>::min();
    
    current_statement__ = 122;
    count = 0;
    current_statement__ = 127;
    for (int i = 1; i <= num_elements(sub); ++i) {
      current_statement__ = 125;
      if (logical_eq(rvalue(sub, "sub", index_uni(i)), index)) {
        current_statement__ = 123;
        count = (count + 1);
      } 
    }
    current_statement__ = 128;
    return count;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct count_sub_functor__ {
int
operator()(const std::vector<int>& sub, const int& index,
           std::ostream* pstream__)  const 
{
return count_sub(sub, index, pstream__);
}
};

template <typename T1__>
int
count_bld(const std::vector<int>& sub, const T1__& dT_arg__,
          const int& index, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T1__>>;
  int current_statement__ = 0; 
  const auto& dT = to_ref(dT_arg__);
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    int count;
    count = std::numeric_limits<int>::min();
    
    current_statement__ = 131;
    count = 0;
    current_statement__ = 138;
    for (int i = 1; i <= num_elements(sub); ++i) {
      current_statement__ = 136;
      if (logical_eq(rvalue(sub, "sub", index_uni(i)), index)) {
        current_statement__ = 134;
        if (logical_eq(rvalue(dT, "dT", index_uni(i)), 0.0)) {
          current_statement__ = 132;
          count = (count + 1);
        } 
      } 
    }
    current_statement__ = 139;
    return count;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct count_bld_functor__ {
template <typename T1__>
int
operator()(const std::vector<int>& sub, const T1__& dT, const int& index,
           std::ostream* pstream__)  const 
{
return count_bld(sub, dT, index, pstream__);
}
};

template <typename T1__>
int
count_urn(const std::vector<int>& sub, const T1__& dT_arg__,
          const int& index, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T1__>>;
  int current_statement__ = 0; 
  const auto& dT = to_ref(dT_arg__);
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    int count;
    count = std::numeric_limits<int>::min();
    
    current_statement__ = 142;
    count = 0;
    current_statement__ = 149;
    for (int i = 1; i <= num_elements(sub); ++i) {
      current_statement__ = 147;
      if (logical_eq(rvalue(sub, "sub", index_uni(i)), index)) {
        current_statement__ = 145;
        if (logical_gt(rvalue(dT, "dT", index_uni(i)), 0.0)) {
          current_statement__ = 143;
          count = (count + 1);
        } 
      } 
    }
    current_statement__ = 150;
    return count;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct count_urn_functor__ {
template <typename T1__>
int
operator()(const std::vector<int>& sub, const T1__& dT, const int& index,
           std::ostream* pstream__)  const 
{
return count_urn(sub, dT, index, pstream__);
}
};

std::vector<int>
inds(const std::vector<int>& sub, const int& index, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0; 
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 152;
    validate_non_negative_index("res", "count_sub(sub, index)",
                                count_sub(sub, index, pstream__));
    std::vector<int> res;
    res = std::vector<int>(count_sub(sub, index, pstream__), std::numeric_limits<int>::min());
    
    
    int ci;
    ci = std::numeric_limits<int>::min();
    
    current_statement__ = 155;
    ci = 1;
    current_statement__ = 161;
    for (int i = 1; i <= num_elements(sub); ++i) {
      current_statement__ = 159;
      if (logical_eq(rvalue(sub, "sub", index_uni(i)), index)) {
        current_statement__ = 156;
        assign(res, i, "assigning variable res", index_uni(ci));
        current_statement__ = 157;
        ci = (ci + 1);
      } 
    }
    current_statement__ = 162;
    return res;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct inds_functor__ {
std::vector<int>
operator()(const std::vector<int>& sub, const int& index,
           std::ostream* pstream__)  const 
{
return inds(sub, index, pstream__);
}
};

template <typename T1__>
std::vector<int>
indu(const std::vector<int>& sub, const T1__& dT_arg__, const int& index,
     std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T1__>>;
  int current_statement__ = 0; 
  const auto& dT = to_ref(dT_arg__);
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 164;
    validate_non_negative_index("res", "count_urn(sub, dT, index)",
                                count_urn(sub, dT, index, pstream__));
    std::vector<int> res;
    res = std::vector<int>(count_urn(sub, dT, index, pstream__), std::numeric_limits<int>::min());
    
    
    int ci;
    ci = std::numeric_limits<int>::min();
    
    current_statement__ = 167;
    ci = 1;
    current_statement__ = 175;
    for (int i = 1; i <= num_elements(sub); ++i) {
      current_statement__ = 173;
      if (logical_eq(rvalue(sub, "sub", index_uni(i)), index)) {
        current_statement__ = 171;
        if (logical_gt(rvalue(dT, "dT", index_uni(i)), 0.0)) {
          current_statement__ = 168;
          assign(res, i, "assigning variable res", index_uni(ci));
          current_statement__ = 169;
          ci = (ci + 1);
        } 
      } 
    }
    current_statement__ = 176;
    return res;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct indu_functor__ {
template <typename T1__>
std::vector<int>
operator()(const std::vector<int>& sub, const T1__& dT, const int& index,
           std::ostream* pstream__)  const 
{
return indu(sub, dT, index, pstream__);
}
};

template <typename T1__>
std::vector<int>
indb(const std::vector<int>& sub, const T1__& dT_arg__, const int& index,
     std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T1__>>;
  int current_statement__ = 0; 
  const auto& dT = to_ref(dT_arg__);
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 178;
    validate_non_negative_index("res", "count_bld(sub, dT, index)",
                                count_bld(sub, dT, index, pstream__));
    std::vector<int> res;
    res = std::vector<int>(count_bld(sub, dT, index, pstream__), std::numeric_limits<int>::min());
    
    
    int ci;
    ci = std::numeric_limits<int>::min();
    
    current_statement__ = 181;
    ci = 1;
    current_statement__ = 189;
    for (int i = 1; i <= num_elements(sub); ++i) {
      current_statement__ = 187;
      if (logical_eq(rvalue(sub, "sub", index_uni(i)), index)) {
        current_statement__ = 185;
        if (logical_eq(rvalue(dT, "dT", index_uni(i)), 0.0)) {
          current_statement__ = 182;
          assign(res, i, "assigning variable res", index_uni(ci));
          current_statement__ = 183;
          ci = (ci + 1);
        } 
      } 
    }
    current_statement__ = 190;
    return res;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct indb_functor__ {
template <typename T1__>
std::vector<int>
operator()(const std::vector<int>& sub, const T1__& dT, const int& index,
           std::ostream* pstream__)  const 
{
return indb(sub, dT, index, pstream__);
}
};

class zircon_all_model final : public model_base_crtp<zircon_all_model> {

 private:
  int ntot;
  int N;
  std::vector<int> n;
  std::vector<int> sub;
  Eigen::Matrix<double, -1, 1> T__;
  Eigen::Matrix<double, -1, 1> dT__;
  Eigen::Matrix<double, -1, 1> M__;
  Eigen::Matrix<double, -1, 1> u__;
  int nt;
  int nc;
  std::vector<std::vector<int>> H;
  Eigen::Matrix<double, -1, 1> mu_v__;
  Eigen::Matrix<double, -1, 1> sigma_v__;
  Eigen::Matrix<double, -1, 1> mu_theta__;
  Eigen::Matrix<double, -1, -1> sigma_theta__;
  double mu_tau;
  double sigma_tau;
  double Eta;
  double df; 
  Eigen::Map<Eigen::Matrix<double, -1, 1>> T{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double, -1, 1>> dT{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double, -1, 1>> M{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double, -1, 1>> u{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double, -1, 1>> mu_v{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double, -1, 1>> sigma_v{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double, -1, 1>> mu_theta{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double, -1, -1>> sigma_theta{nullptr, 0, 0};
 
 public:
  ~zircon_all_model() { }
  
  inline std::string model_name() const final { return "zircon_all_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = stanc3 v2.27.0", "stancflags = "};
  }
  
  
  zircon_all_model(stan::io::var_context& context__,
                   unsigned int random_seed__ = 0,
                   std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "zircon_all_model_namespace::zircon_all_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      current_statement__ = 34;
      context__.validate_dims("data initialization","ntot","int",
           std::vector<size_t>{});
      ntot = std::numeric_limits<int>::min();
      
      current_statement__ = 34;
      ntot = context__.vals_i("ntot")[(1 - 1)];
      current_statement__ = 35;
      context__.validate_dims("data initialization","N","int",
           std::vector<size_t>{});
      N = std::numeric_limits<int>::min();
      
      current_statement__ = 35;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 36;
      validate_non_negative_index("n", "N", N);
      current_statement__ = 37;
      context__.validate_dims("data initialization","n","int",
           std::vector<size_t>{static_cast<size_t>(N)});
      n = std::vector<int>(N, std::numeric_limits<int>::min());
      
      current_statement__ = 37;
      n = context__.vals_i("n");
      current_statement__ = 38;
      validate_non_negative_index("sub", "ntot", ntot);
      current_statement__ = 39;
      context__.validate_dims("data initialization","sub","int",
           std::vector<size_t>{static_cast<size_t>(ntot)});
      sub = std::vector<int>(ntot, std::numeric_limits<int>::min());
      
      current_statement__ = 39;
      sub = context__.vals_i("sub");
      current_statement__ = 40;
      validate_non_negative_index("T", "ntot", ntot);
      current_statement__ = 41;
      context__.validate_dims("data initialization","T","double",
           std::vector<size_t>{static_cast<size_t>(ntot)});
      T__ = Eigen::Matrix<double, -1, 1>(ntot);
      new (&T) Eigen::Map<Eigen::Matrix<double, -1, 1>>(T__.data(), ntot);
      
      {
        std::vector<local_scalar_t__> T_flat__;
        current_statement__ = 41;
        T_flat__ = context__.vals_r("T");
        current_statement__ = 41;
        pos__ = 1;
        current_statement__ = 41;
        for (int sym1__ = 1; sym1__ <= ntot; ++sym1__) {
          current_statement__ = 41;
          assign(T, T_flat__[(pos__ - 1)],
            "assigning variable T", index_uni(sym1__));
          current_statement__ = 41;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 42;
      validate_non_negative_index("dT", "ntot", ntot);
      current_statement__ = 43;
      context__.validate_dims("data initialization","dT","double",
           std::vector<size_t>{static_cast<size_t>(ntot)});
      dT__ = Eigen::Matrix<double, -1, 1>(ntot);
      new (&dT) Eigen::Map<Eigen::Matrix<double, -1, 1>>(dT__.data(), ntot);
      
      {
        std::vector<local_scalar_t__> dT_flat__;
        current_statement__ = 43;
        dT_flat__ = context__.vals_r("dT");
        current_statement__ = 43;
        pos__ = 1;
        current_statement__ = 43;
        for (int sym1__ = 1; sym1__ <= ntot; ++sym1__) {
          current_statement__ = 43;
          assign(dT, dT_flat__[(pos__ - 1)],
            "assigning variable dT", index_uni(sym1__));
          current_statement__ = 43;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 44;
      validate_non_negative_index("M", "ntot", ntot);
      current_statement__ = 45;
      context__.validate_dims("data initialization","M","double",
           std::vector<size_t>{static_cast<size_t>(ntot)});
      M__ = Eigen::Matrix<double, -1, 1>(ntot);
      new (&M) Eigen::Map<Eigen::Matrix<double, -1, 1>>(M__.data(), ntot);
      
      {
        std::vector<local_scalar_t__> M_flat__;
        current_statement__ = 45;
        M_flat__ = context__.vals_r("M");
        current_statement__ = 45;
        pos__ = 1;
        current_statement__ = 45;
        for (int sym1__ = 1; sym1__ <= ntot; ++sym1__) {
          current_statement__ = 45;
          assign(M, M_flat__[(pos__ - 1)],
            "assigning variable M", index_uni(sym1__));
          current_statement__ = 45;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 46;
      validate_non_negative_index("u", "ntot", ntot);
      current_statement__ = 47;
      context__.validate_dims("data initialization","u","double",
           std::vector<size_t>{static_cast<size_t>(ntot)});
      u__ = Eigen::Matrix<double, -1, 1>(ntot);
      new (&u) Eigen::Map<Eigen::Matrix<double, -1, 1>>(u__.data(), ntot);
      
      {
        std::vector<local_scalar_t__> u_flat__;
        current_statement__ = 47;
        u_flat__ = context__.vals_r("u");
        current_statement__ = 47;
        pos__ = 1;
        current_statement__ = 47;
        for (int sym1__ = 1; sym1__ <= ntot; ++sym1__) {
          current_statement__ = 47;
          assign(u, u_flat__[(pos__ - 1)],
            "assigning variable u", index_uni(sym1__));
          current_statement__ = 47;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 48;
      context__.validate_dims("data initialization","nt","int",
           std::vector<size_t>{});
      nt = std::numeric_limits<int>::min();
      
      current_statement__ = 48;
      nt = context__.vals_i("nt")[(1 - 1)];
      current_statement__ = 49;
      context__.validate_dims("data initialization","nc","int",
           std::vector<size_t>{});
      nc = std::numeric_limits<int>::min();
      
      current_statement__ = 49;
      nc = context__.vals_i("nc")[(1 - 1)];
      current_statement__ = 50;
      validate_non_negative_index("H", "nt", nt);
      current_statement__ = 51;
      context__.validate_dims("data initialization","H","int",
           std::vector<size_t>{static_cast<size_t>(nt),
            static_cast<size_t>(2)});
      H = std::vector<std::vector<int>>(nt, std::vector<int>(2, std::numeric_limits<int>::min()));
      
      
      {
        std::vector<int> H_flat__;
        current_statement__ = 51;
        H_flat__ = context__.vals_i("H");
        current_statement__ = 51;
        pos__ = 1;
        current_statement__ = 51;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          current_statement__ = 51;
          for (int sym2__ = 1; sym2__ <= nt; ++sym2__) {
            current_statement__ = 51;
            assign(H, H_flat__[(pos__ - 1)],
              "assigning variable H", index_uni(sym2__), index_uni(sym1__));
            current_statement__ = 51;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 52;
      validate_non_negative_index("mu_v", "N", N);
      current_statement__ = 53;
      context__.validate_dims("data initialization","mu_v","double",
           std::vector<size_t>{static_cast<size_t>(N)});
      mu_v__ = Eigen::Matrix<double, -1, 1>(N);
      new (&mu_v) Eigen::Map<Eigen::Matrix<double, -1, 1>>(mu_v__.data(), N);
      
      {
        std::vector<local_scalar_t__> mu_v_flat__;
        current_statement__ = 53;
        mu_v_flat__ = context__.vals_r("mu_v");
        current_statement__ = 53;
        pos__ = 1;
        current_statement__ = 53;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 53;
          assign(mu_v, mu_v_flat__[(pos__ - 1)],
            "assigning variable mu_v", index_uni(sym1__));
          current_statement__ = 53;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 54;
      validate_non_negative_index("sigma_v", "N", N);
      current_statement__ = 55;
      context__.validate_dims("data initialization","sigma_v","double",
           std::vector<size_t>{static_cast<size_t>(N)});
      sigma_v__ = Eigen::Matrix<double, -1, 1>(N);
      new (&sigma_v) Eigen::Map<Eigen::Matrix<double, -1, 1>>(sigma_v__.data(), N);
      
      
      {
        std::vector<local_scalar_t__> sigma_v_flat__;
        current_statement__ = 55;
        sigma_v_flat__ = context__.vals_r("sigma_v");
        current_statement__ = 55;
        pos__ = 1;
        current_statement__ = 55;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 55;
          assign(sigma_v, sigma_v_flat__[(pos__ - 1)],
            "assigning variable sigma_v", index_uni(sym1__));
          current_statement__ = 55;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 56;
      validate_non_negative_index("mu_theta", "nt", nt);
      current_statement__ = 57;
      context__.validate_dims("data initialization","mu_theta","double",
           std::vector<size_t>{static_cast<size_t>(nt)});
      mu_theta__ = Eigen::Matrix<double, -1, 1>(nt);
      new (&mu_theta) Eigen::Map<Eigen::Matrix<double, -1, 1>>(mu_theta__.data(), nt);
      
      
      {
        std::vector<local_scalar_t__> mu_theta_flat__;
        current_statement__ = 57;
        mu_theta_flat__ = context__.vals_r("mu_theta");
        current_statement__ = 57;
        pos__ = 1;
        current_statement__ = 57;
        for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
          current_statement__ = 57;
          assign(mu_theta, mu_theta_flat__[(pos__ - 1)],
            "assigning variable mu_theta", index_uni(sym1__));
          current_statement__ = 57;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 58;
      validate_non_negative_index("sigma_theta", "nt", nt);
      current_statement__ = 59;
      validate_non_negative_index("sigma_theta", "nt", nt);
      current_statement__ = 60;
      context__.validate_dims("data initialization","sigma_theta","double",
           std::vector<size_t>{static_cast<size_t>(nt),
            static_cast<size_t>(nt)});
      sigma_theta__ = Eigen::Matrix<double, -1, -1>(nt, nt);
      new (&sigma_theta) Eigen::Map<Eigen::Matrix<double, -1, -1>>(sigma_theta__.data(), nt, nt);
      
      
      {
        std::vector<local_scalar_t__> sigma_theta_flat__;
        current_statement__ = 60;
        sigma_theta_flat__ = context__.vals_r("sigma_theta");
        current_statement__ = 60;
        pos__ = 1;
        current_statement__ = 60;
        for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
          current_statement__ = 60;
          for (int sym2__ = 1; sym2__ <= nt; ++sym2__) {
            current_statement__ = 60;
            assign(sigma_theta, sigma_theta_flat__[(pos__ - 1)],
              "assigning variable sigma_theta", index_uni(sym2__),
                                                  index_uni(sym1__));
            current_statement__ = 60;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 61;
      context__.validate_dims("data initialization","mu_tau","double",
           std::vector<size_t>{});
      mu_tau = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 61;
      mu_tau = context__.vals_r("mu_tau")[(1 - 1)];
      current_statement__ = 62;
      context__.validate_dims("data initialization","sigma_tau","double",
           std::vector<size_t>{});
      sigma_tau = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 62;
      sigma_tau = context__.vals_r("sigma_tau")[(1 - 1)];
      current_statement__ = 63;
      context__.validate_dims("data initialization","Eta","double",
           std::vector<size_t>{});
      Eta = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 63;
      Eta = context__.vals_r("Eta")[(1 - 1)];
      current_statement__ = 64;
      context__.validate_dims("data initialization","df","double",
           std::vector<size_t>{});
      df = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 64;
      df = context__.vals_r("df")[(1 - 1)];
      current_statement__ = 65;
      validate_non_negative_index("V", "N", N);
      current_statement__ = 66;
      validate_non_negative_index("Kt", "nt", nt);
      current_statement__ = 67;
      validate_non_negative_index("Kt", "N", N);
      current_statement__ = 68;
      validate_non_negative_index("Omega", "nt", nt);
      current_statement__ = 68;
      validate_non_negative_index("Omega", "nt", nt);
      current_statement__ = 69;
      validate_non_negative_index("theta", "nt", nt);
      current_statement__ = 70;
      validate_non_negative_index("Pi", "nt", nt);
      current_statement__ = 70;
      validate_non_negative_index("Pi", "nt", nt);
      current_statement__ = 71;
      validate_non_negative_index("Tau", "nt", nt);
      current_statement__ = 72;
      validate_non_negative_index("kt", "nt", nt);
      current_statement__ = 73;
      validate_non_negative_index("m", "ntot", ntot);
      current_statement__ = 74;
      validate_non_negative_index("M_hat", "ntot", ntot);
      current_statement__ = 75;
      validate_non_negative_index("log_lik", "ntot", ntot);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = N + (nt * N) + ((nt * (nt - 1)) / 2) + 1 + nt;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "zircon_all_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      Eigen::Matrix<local_scalar_t__, -1, 1> V;
      V = Eigen::Matrix<local_scalar_t__, -1, 1>(N);
      stan::math::fill(V, DUMMY_VAR__);
      
      current_statement__ = 1;
      V = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(N);
      Eigen::Matrix<local_scalar_t__, -1, -1> Kt;
      Kt = Eigen::Matrix<local_scalar_t__, -1, -1>(nt, N);
      stan::math::fill(Kt, DUMMY_VAR__);
      
      current_statement__ = 2;
      Kt = in__.template read<Eigen::Matrix<local_scalar_t__, -1, -1>>(nt, N);
      Eigen::Matrix<local_scalar_t__, -1, -1> Omega;
      Omega = Eigen::Matrix<local_scalar_t__, -1, -1>(nt, nt);
      stan::math::fill(Omega, DUMMY_VAR__);
      
      current_statement__ = 3;
      Omega = in__.template read_constrain_corr_matrix<Eigen::Matrix<local_scalar_t__, -1, -1>, jacobian__>(
                lp__, nt);
      local_scalar_t__ tau;
      tau = DUMMY_VAR__;
      
      current_statement__ = 4;
      tau = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
              lp__);
      Eigen::Matrix<local_scalar_t__, -1, 1> theta;
      theta = Eigen::Matrix<local_scalar_t__, -1, 1>(nt);
      stan::math::fill(theta, DUMMY_VAR__);
      
      current_statement__ = 5;
      theta = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(nt);
      Eigen::Matrix<local_scalar_t__, -1, -1> Pi;
      Pi = Eigen::Matrix<local_scalar_t__, -1, -1>(nt, nt);
      stan::math::fill(Pi, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, 1> Tau;
      Tau = Eigen::Matrix<local_scalar_t__, -1, 1>(nt);
      stan::math::fill(Tau, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, 1> kt;
      kt = Eigen::Matrix<local_scalar_t__, -1, 1>(nt);
      stan::math::fill(kt, DUMMY_VAR__);
      
      local_scalar_t__ v;
      v = DUMMY_VAR__;
      
      Eigen::Matrix<local_scalar_t__, -1, 1> m;
      m = Eigen::Matrix<local_scalar_t__, -1, 1>(ntot);
      stan::math::fill(m, DUMMY_VAR__);
      
      current_statement__ = 11;
      assign(Tau, rep_vector(tau, nt), "assigning variable Tau");
      current_statement__ = 12;
      assign(Pi, quad_form_diag(Omega, Tau), "assigning variable Pi");
      current_statement__ = 18;
      for (int i = 1; i <= N; ++i) {
        current_statement__ = 13;
        assign(kt,
          stan::math::exp(
            rvalue(Kt, "Kt", index_min_max(1, nt), index_uni(i))),
          "assigning variable kt");
        current_statement__ = 14;
        v = stan::math::exp(rvalue(V, "V", index_uni(i)));
        current_statement__ = 15;
        assign(m,
          divide(
            add(
              q_c(1,
                rvalue(T, "T", index_multi(indb(sub, dT, i, pstream__))), kt,
                H, nc, nt, pstream__),
              q_c(2,
                rvalue(T, "T", index_multi(indb(sub, dT, i, pstream__))), kt,
                H, nc, nt, pstream__)), v),
          "assigning variable m", index_multi(indb(sub, dT, i, pstream__)));
        current_statement__ = 16;
        assign(m,
          subtract(
            q_c(15, rvalue(T, "T", index_multi(indu(sub, dT, i, pstream__))),
              kt, H, nc, nt, pstream__),
            q_c(15,
              subtract(
                rvalue(T, "T", index_multi(indu(sub, dT, i, pstream__))),
                rvalue(dT, "dT", index_multi(indu(sub, dT, i, pstream__)))),
              kt, H, nc, nt, pstream__)),
          "assigning variable m", index_multi(indu(sub, dT, i, pstream__)));
      }
      current_statement__ = 6;
      check_cov_matrix(function__, "Pi", Pi);
      {
        current_statement__ = 26;
        lp_accum__.add(lkj_corr_lpdf<propto__>(Omega, Eta));
        current_statement__ = 27;
        lp_accum__.add(
          multi_normal_lpdf<propto__>(theta, mu_theta, sigma_theta));
        current_statement__ = 28;
        lp_accum__.add(normal_lpdf<propto__>(tau, mu_tau, sigma_tau));
        current_statement__ = 33;
        for (int i = 1; i <= N; ++i) {
          current_statement__ = 29;
          lp_accum__.add(
            multi_normal_lpdf<propto__>(
              rvalue(Kt, "Kt", index_min_max(1, nt), index_uni(i)), theta,
              Pi));
          current_statement__ = 30;
          lp_accum__.add(
            normal_lpdf<propto__>(rvalue(V, "V", index_uni(i)),
              rvalue(mu_v, "mu_v", index_uni(i)),
              rvalue(sigma_v, "sigma_v", index_uni(i))));
          current_statement__ = 31;
          lp_accum__.add(
            student_t_lpdf<propto__>(
              rvalue(M, "M", index_multi(inds(sub, i, pstream__))), df,
              rvalue(m, "m", index_multi(inds(sub, i, pstream__))),
              rvalue(u, "u", index_multi(inds(sub, i, pstream__)))));
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "zircon_all_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      Eigen::Matrix<double, -1, 1> V;
      V = Eigen::Matrix<double, -1, 1>(N);
      stan::math::fill(V, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 1;
      V = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(N);
      Eigen::Matrix<double, -1, -1> Kt;
      Kt = Eigen::Matrix<double, -1, -1>(nt, N);
      stan::math::fill(Kt, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 2;
      Kt = in__.template read<Eigen::Matrix<local_scalar_t__, -1, -1>>(nt, N);
      Eigen::Matrix<double, -1, -1> Omega;
      Omega = Eigen::Matrix<double, -1, -1>(nt, nt);
      stan::math::fill(Omega, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 3;
      Omega = in__.template read_constrain_corr_matrix<Eigen::Matrix<local_scalar_t__, -1, -1>, jacobian__>(
                lp__, nt);
      double tau;
      tau = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 4;
      tau = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
              lp__);
      Eigen::Matrix<double, -1, 1> theta;
      theta = Eigen::Matrix<double, -1, 1>(nt);
      stan::math::fill(theta, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 5;
      theta = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(nt);
      Eigen::Matrix<double, -1, -1> Pi;
      Pi = Eigen::Matrix<double, -1, -1>(nt, nt);
      stan::math::fill(Pi, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, 1> Tau;
      Tau = Eigen::Matrix<double, -1, 1>(nt);
      stan::math::fill(Tau, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, 1> kt;
      kt = Eigen::Matrix<double, -1, 1>(nt);
      stan::math::fill(kt, std::numeric_limits<double>::quiet_NaN());
      
      double v;
      v = std::numeric_limits<double>::quiet_NaN();
      
      Eigen::Matrix<double, -1, 1> m;
      m = Eigen::Matrix<double, -1, 1>(ntot);
      stan::math::fill(m, std::numeric_limits<double>::quiet_NaN());
      
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        vars__.emplace_back(V[(sym1__ - 1)]);
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= nt; ++sym2__) {
          vars__.emplace_back(
            rvalue(Kt, "Kt", index_uni(sym2__), index_uni(sym1__)));
        }
      }
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= nt; ++sym2__) {
          vars__.emplace_back(
            rvalue(Omega, "Omega", index_uni(sym2__), index_uni(sym1__)));
        }
      }
      vars__.emplace_back(tau);
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        vars__.emplace_back(theta[(sym1__ - 1)]);
      }
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 11;
      assign(Tau, rep_vector(tau, nt), "assigning variable Tau");
      current_statement__ = 12;
      assign(Pi, quad_form_diag(Omega, Tau), "assigning variable Pi");
      current_statement__ = 18;
      for (int i = 1; i <= N; ++i) {
        current_statement__ = 13;
        assign(kt,
          stan::math::exp(
            rvalue(Kt, "Kt", index_min_max(1, nt), index_uni(i))),
          "assigning variable kt");
        current_statement__ = 14;
        v = stan::math::exp(rvalue(V, "V", index_uni(i)));
        current_statement__ = 15;
        assign(m,
          divide(
            add(
              q_c(1,
                rvalue(T, "T", index_multi(indb(sub, dT, i, pstream__))), kt,
                H, nc, nt, pstream__),
              q_c(2,
                rvalue(T, "T", index_multi(indb(sub, dT, i, pstream__))), kt,
                H, nc, nt, pstream__)), v),
          "assigning variable m", index_multi(indb(sub, dT, i, pstream__)));
        current_statement__ = 16;
        assign(m,
          subtract(
            q_c(15, rvalue(T, "T", index_multi(indu(sub, dT, i, pstream__))),
              kt, H, nc, nt, pstream__),
            q_c(15,
              subtract(
                rvalue(T, "T", index_multi(indu(sub, dT, i, pstream__))),
                rvalue(dT, "dT", index_multi(indu(sub, dT, i, pstream__)))),
              kt, H, nc, nt, pstream__)),
          "assigning variable m", index_multi(indu(sub, dT, i, pstream__)));
      }
      current_statement__ = 6;
      check_cov_matrix(function__, "Pi", Pi);
      if (emit_transformed_parameters__) {
        for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= nt; ++sym2__) {
            vars__.emplace_back(
              rvalue(Pi, "Pi", index_uni(sym2__), index_uni(sym1__)));
          }
        }
        for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
          vars__.emplace_back(Tau[(sym1__ - 1)]);
        }
        for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
          vars__.emplace_back(kt[(sym1__ - 1)]);
        }
        vars__.emplace_back(v);
        for (int sym1__ = 1; sym1__ <= ntot; ++sym1__) {
          vars__.emplace_back(m[(sym1__ - 1)]);
        }
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
      std::vector<double> M_hat;
      M_hat = std::vector<double>(ntot, std::numeric_limits<double>::quiet_NaN());
      
      
      std::vector<double> log_lik;
      log_lik = std::vector<double>(ntot, std::numeric_limits<double>::quiet_NaN());
      
      
      current_statement__ = 25;
      for (int i = 1; i <= N; ++i) {
        current_statement__ = 21;
        assign(M_hat,
          student_t_rng(df,
            rvalue(m, "m", index_multi(inds(sub, i, pstream__))),
            rvalue(u, "u", index_multi(inds(sub, i, pstream__))), base_rng__),
          "assigning variable M_hat", index_multi(inds(sub, i, pstream__)));
        {
          std::vector<int> sym1__;
          current_statement__ = 22;
          assign(sym1__, inds(sub, i, pstream__), "assigning variable sym1__");
          current_statement__ = 22;
          for (int sym2__ = 1; sym2__ <= stan::math::size(sym1__); ++sym2__) {
            {
              int j;
              current_statement__ = 22;
              j = sym1__[(sym2__ - 1)];
              current_statement__ = 23;
              assign(log_lik,
                student_t_lpdf<false>(rvalue(M, "M", index_uni(j)), df,
                  rvalue(m, "m", index_uni(j)), rvalue(u, "u", index_uni(j))),
                "assigning variable log_lik", index_uni(j));
            }
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= ntot; ++sym1__) {
        vars__.emplace_back(M_hat[(sym1__ - 1)]);
      }
      for (int sym1__ = 1; sym1__ <= ntot; ++sym1__) {
        vars__.emplace_back(log_lik[(sym1__ - 1)]);
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(const stan::io::var_context& context__,
                                   VecI& params_i__, VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.clear();
    vars__.reserve(num_params_r__);
    int current_statement__ = 0; 
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      Eigen::Matrix<double, -1, 1> V;
      V = Eigen::Matrix<double, -1, 1>(N);
      stan::math::fill(V, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> V_flat__;
        current_statement__ = 1;
        V_flat__ = context__.vals_r("V");
        current_statement__ = 1;
        pos__ = 1;
        current_statement__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 1;
          assign(V, V_flat__[(pos__ - 1)],
            "assigning variable V", index_uni(sym1__));
          current_statement__ = 1;
          pos__ = (pos__ + 1);
        }
      }
      Eigen::Matrix<double, -1, -1> Kt;
      Kt = Eigen::Matrix<double, -1, -1>(nt, N);
      stan::math::fill(Kt, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> Kt_flat__;
        current_statement__ = 2;
        Kt_flat__ = context__.vals_r("Kt");
        current_statement__ = 2;
        pos__ = 1;
        current_statement__ = 2;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 2;
          for (int sym2__ = 1; sym2__ <= nt; ++sym2__) {
            current_statement__ = 2;
            assign(Kt, Kt_flat__[(pos__ - 1)],
              "assigning variable Kt", index_uni(sym2__), index_uni(sym1__));
            current_statement__ = 2;
            pos__ = (pos__ + 1);
          }
        }
      }
      Eigen::Matrix<double, -1, -1> Omega;
      Omega = Eigen::Matrix<double, -1, -1>(nt, nt);
      stan::math::fill(Omega, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> Omega_flat__;
        current_statement__ = 3;
        Omega_flat__ = context__.vals_r("Omega");
        current_statement__ = 3;
        pos__ = 1;
        current_statement__ = 3;
        for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
          current_statement__ = 3;
          for (int sym2__ = 1; sym2__ <= nt; ++sym2__) {
            current_statement__ = 3;
            assign(Omega, Omega_flat__[(pos__ - 1)],
              "assigning variable Omega", index_uni(sym2__),
                                            index_uni(sym1__));
            current_statement__ = 3;
            pos__ = (pos__ + 1);
          }
        }
      }
      Eigen::Matrix<double, -1, 1> Omega_free__;
      Omega_free__ = Eigen::Matrix<double, -1, 1>(((nt * (nt - 1)) / 2));
      stan::math::fill(Omega_free__, std::numeric_limits<double>::quiet_NaN());
      
      
      current_statement__ = 3;
      assign(Omega_free__, stan::math::corr_matrix_free(Omega),
        "assigning variable Omega_free__");
      double tau;
      tau = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 4;
      tau = context__.vals_r("tau")[(1 - 1)];
      double tau_free__;
      tau_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 4;
      tau_free__ = stan::math::lb_free(tau, 0);
      Eigen::Matrix<double, -1, 1> theta;
      theta = Eigen::Matrix<double, -1, 1>(nt);
      stan::math::fill(theta, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> theta_flat__;
        current_statement__ = 5;
        theta_flat__ = context__.vals_r("theta");
        current_statement__ = 5;
        pos__ = 1;
        current_statement__ = 5;
        for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
          current_statement__ = 5;
          assign(theta, theta_flat__[(pos__ - 1)],
            "assigning variable theta", index_uni(sym1__));
          current_statement__ = 5;
          pos__ = (pos__ + 1);
        }
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        vars__.emplace_back(V[(sym1__ - 1)]);
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= nt; ++sym2__) {
          vars__.emplace_back(
            rvalue(Kt, "Kt", index_uni(sym2__), index_uni(sym1__)));
        }
      }
      for (int sym1__ = 1; sym1__ <= ((nt * (nt - 1)) / 2); ++sym1__) {
        vars__.emplace_back(Omega_free__[(sym1__ - 1)]);
      }
      vars__.emplace_back(tau_free__);
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        vars__.emplace_back(theta[(sym1__ - 1)]);
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"V", "Kt", "Omega", "tau", "theta",
      "Pi", "Tau", "kt", "v", "m", "M_hat", "log_lik"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{
                                                                   static_cast<size_t>(N)
                                                                   },
      std::vector<size_t>{static_cast<size_t>(nt), static_cast<size_t>(N)},
      std::vector<size_t>{static_cast<size_t>(nt), static_cast<size_t>(nt)},
      std::vector<size_t>{}, std::vector<size_t>{static_cast<size_t>(nt)},
      std::vector<size_t>{static_cast<size_t>(nt), static_cast<size_t>(nt)},
      std::vector<size_t>{static_cast<size_t>(nt)},
      std::vector<size_t>{static_cast<size_t>(nt)}, std::vector<size_t>{
      }, std::vector<size_t>{static_cast<size_t>(ntot)},
      std::vector<size_t>{static_cast<size_t>(ntot)},
      std::vector<size_t>{static_cast<size_t>(ntot)}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "V" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= nt; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "Kt" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= nt; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "Omega" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    param_names__.emplace_back(std::string() + "tau");
    for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "theta" + '.' + std::to_string(sym1__));
      } 
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nt; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "Pi" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "Tau" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "kt" + '.' + std::to_string(sym1__));
        } 
      }
      param_names__.emplace_back(std::string() + "v");
      for (int sym1__ = 1; sym1__ <= ntot; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "m" + '.' + std::to_string(sym1__));
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      for (int sym1__ = 1; sym1__ <= ntot; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "M_hat" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= ntot; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "log_lik" + '.' + std::to_string(sym1__));
        } 
      }
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "V" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= nt; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "Kt" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    for (int sym1__ = 1; sym1__ <= ((nt * (nt - 1)) / 2); ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "Omega" + '.' + std::to_string(sym1__));
      } 
    }
    param_names__.emplace_back(std::string() + "tau");
    for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "theta" + '.' + std::to_string(sym1__));
      } 
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= (nt + ((nt * (nt - 1)) / 2)); ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "Pi" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "Tau" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "kt" + '.' + std::to_string(sym1__));
        } 
      }
      param_names__.emplace_back(std::string() + "v");
      for (int sym1__ = 1; sym1__ <= ntot; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "m" + '.' + std::to_string(sym1__));
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      for (int sym1__ = 1; sym1__ <= ntot; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "M_hat" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= ntot; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "log_lik" + '.' + std::to_string(sym1__));
        } 
      }
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"V\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"Kt\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nt) + ",\"cols\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"Omega\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nt) + ",\"cols\":" + std::to_string(nt) + "},\"block\":\"parameters\"},{\"name\":\"tau\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(nt) + "},\"block\":\"parameters\"},{\"name\":\"Pi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nt) + ",\"cols\":" + std::to_string(nt) + "},\"block\":\"transformed_parameters\"},{\"name\":\"Tau\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(nt) + "},\"block\":\"transformed_parameters\"},{\"name\":\"kt\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(nt) + "},\"block\":\"transformed_parameters\"},{\"name\":\"v\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"m\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(ntot) + "},\"block\":\"transformed_parameters\"},{\"name\":\"M_hat\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(ntot) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"generated_quantities\"},{\"name\":\"log_lik\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(ntot) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"generated_quantities\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"V\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"Kt\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nt) + ",\"cols\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"Omega\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(((nt * (nt - 1)) / 2)) + "},\"block\":\"parameters\"},{\"name\":\"tau\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(nt) + "},\"block\":\"parameters\"},{\"name\":\"Pi\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string((nt + ((nt * (nt - 1)) / 2))) + "},\"block\":\"transformed_parameters\"},{\"name\":\"Tau\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(nt) + "},\"block\":\"transformed_parameters\"},{\"name\":\"kt\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(nt) + "},\"block\":\"transformed_parameters\"},{\"name\":\"v\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"m\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(ntot) + "},\"block\":\"transformed_parameters\"},{\"name\":\"M_hat\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(ntot) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"generated_quantities\"},{\"name\":\"log_lik\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(ntot) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"generated_quantities\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      std::vector<double> vars_vec;
      vars_vec.reserve(vars.size());
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      write_array_impl(base_rng, params_r, params_i, vars,
       emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec;
      params_r_vec.reserve(params_r.size());
      std::vector<int> params_i;
      transform_inits_impl(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }
    inline void transform_inits(const stan::io::var_context& context,
                                std::vector<int>& params_i,
                                std::vector<double>& vars,
                                std::ostream* pstream = nullptr) const final {
      transform_inits_impl(context, params_i, vars, pstream);
    }

};
}
using stan_model = zircon_all_model_namespace::zircon_all_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return zircon_all_model_namespace::profiles__;
}

#endif


